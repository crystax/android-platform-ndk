#!/usr/bin/env ruby

# Copyright (c) 2011-2015 CrystaX .NET.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright notice, this list of
#       conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above copyright notice, this list
#       of conditions and the following disclaimer in the documentation and/or other materials
#       provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY CrystaX .NET ''AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CrystaX .NET OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are those of the
# authors and should not be interpreted as representing official policies, either expressed
# or implied, of CrystaX .NET.

require 'fileutils'
require 'pathname'
require 'digest'

MYNAME = Pathname.new(File.expand_path(__FILE__)).relative_path_from(Pathname.new(File.expand_path('../..', __FILE__))).to_s

TOPDIR = File.realpath(File.join(File.dirname(__FILE__), '..'))
SRCDIR = File.realpath(File.join(TOPDIR, 'vendor', 'libpwq'))

PRIVATEDIR = File.join(TOPDIR, 'gen', 'libpwq')
PUBLICDIR  = File.join(TOPDIR, 'include')

class Generator
    def initialize
        @files = []
    end

    def license
        @license = File.read(File.join(TOPDIR, 'LICENSE')).split("\n").map(&:chomp) if @license.nil?
        @license
    end
    private :license

    def relpath(path, from)
        Pathname.new(path).relative_path_from(Pathname.new(from)).to_s
    end
    private :relpath

    def add(f, options = {})
        raise "No such file: #{f}" unless File.exists?(File.join(SRCDIR, f))
        raise "File #{f} already added" if @files.include?(f)
        @files << {file: f, options: options}
    end

    def generate
        total = @files.size
        current = 0
        @files.each do |e|
            f = e[:file]
            options = e[:options]

            src = File.join(SRCDIR, f)
            mdst = File.join(options[:public] ? File.join(PUBLICDIR, 'crystax', 'libpwq') : PRIVATEDIR, File.dirname(f), "mangled-#{File.basename(f)}")

            if options[:public]
                f = f.split('/')[1..-1].join('/') if f =~ /^include\//
                dst = File.join(PUBLICDIR, f)
            else
                dst = File.join(PRIVATEDIR, f)
            end

            symdst = []
            if options[:symlink]
                symsrc = options[:symlink]
                symsrc = [symsrc] unless symsrc.is_a?(Array)
                symdst += symsrc.map { |es| File.join(PRIVATEDIR, es) }
            end

            next if File.exists?(dst) && File.exists?(mdst) &&
                File.mtime(dst)  >= File.mtime(mdst) &&
                File.mtime(mdst) >= File.mtime(src) &&
                File.mtime(dst)  >= File.mtime(__FILE__) &&
                File.mtime(mdst) >= File.mtime(__FILE__)

            current += 1
            puts "GEN  [#{current}/#{total}] #{f}"

            FileUtils.rm_f mdst
            FileUtils.mkdir_p File.dirname(mdst)
            FileUtils.cp src, mdst

            FileUtils.mkdir_p File.dirname(dst)
            File.open(dst, "w") do |df|
                df.puts "/* WARNING!!! THIS IS AUTO-GENERATED FILE!!! DO NOT MODIFY IT MANUALLY!!! */"
                df.puts "/* GENERATED BY: $CRYSTAX/#{MYNAME} */"
                df.puts ""

                df.puts "/*"
                license.each do |line|
                    df.puts " * #{line}".rstrip
                end
                df.puts " */"

                guard = "__CRYSTAX_INCLUDE_#{Digest::SHA256.new.update(relpath(dst, TOPDIR)).hexdigest}".upcase
                df.puts ""
                df.puts "#ifndef #{guard}"
                df.puts "#define #{guard}"

                df.puts ""
                if options[:public]
                    df.puts "#include <crystax/id.h>"
                    df.puts "#include <#{relpath(mdst, File.join(TOPDIR, 'include'))}>"
                else
                    df.puts "#include \"#{File.basename(mdst)}\""
                end

                df.puts ""
                df.puts "#endif /* #{guard} */"
            end

            symdst.each do |sd|
                FileUtils.mkdir_p File.dirname(sd)
                FileUtils.rm_f sd
                FileUtils.ln_s mdst, sd
            end
        end
    end
end

g = Generator.new

g.add "include/pthread_workqueue.h", public: true

g.add "src/linux/platform.h", symlink: ["src/posix/linux/platform.h", "src/linux/linux/platform.h"]
g.add "src/posix/platform.h", symlink: ["src/posix/posix/platform.h", "src/linux/posix/platform.h"]

g.add "src/debug.h",          symlink: ["src/posix/debug.h",       "src/linux/debug.h"]
g.add "src/private.h",        symlink: ["src/posix/private.h",     "src/linux/private.h"]
g.add "src/thread_info.h",    symlink: ["src/posix/thread_info.h", "src/linux/thread_info.h"]
g.add "src/thread_rt.h",      symlink: ["src/posix/thread_rt.h",   "src/linux/thread_rt.h"]

g.add "src/api.c"
g.add "src/linux/load.c"
g.add "src/linux/thread_info.c"
g.add "src/linux/thread_rt.c"
g.add "src/posix/manager.c"
g.add "src/witem_cache.c"

g.generate
